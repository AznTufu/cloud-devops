name: CI/CD Pipeline Todo App

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  CLIENT_IMAGE: ${{ secrets.DOCKER_USERNAME }}/cloud-devops-app-frontend
  SERVER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/cloud-devops-app-backend

jobs:
  # Job 1: Build et Test
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: ğŸ“¦ Install server dependencies
        run: |
          cd server
          npm install

      - name: ğŸ“¦ Install client dependencies  
        run: |
          cd client
          npm install

      - name: ğŸ”§ Build client
        run: |
          cd client
          npm run build

      - name: âœ… Test completed
        run: echo "âœ… Tests passed successfully!"

  # Job 2: Build et Push Docker Images
  docker-build-push:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”‘ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: ğŸ·ï¸ Extract metadata
        id: meta
        run: |
          echo "SHORT_SHA=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          echo "DATE=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
          echo "VERSION=v1.0.${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT

      - name: ğŸ—ï¸ Build and push server image
        uses: docker/build-push-action@v5
        with:
          context: ./server
          file: ./server/Dockerfile
          push: true
          tags: |
            ${{ env.SERVER_IMAGE }}:latest
            ${{ env.SERVER_IMAGE }}:${{ steps.meta.outputs.VERSION }}
            ${{ env.SERVER_IMAGE }}:${{ steps.meta.outputs.SHORT_SHA }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ğŸ—ï¸ Build and push client image
        uses: docker/build-push-action@v5
        with:
          context: ./client
          file: ./client/Dockerfile
          push: true
          tags: |
            ${{ env.CLIENT_IMAGE }}:latest
            ${{ env.CLIENT_IMAGE }}:${{ steps.meta.outputs.VERSION }}
            ${{ env.CLIENT_IMAGE }}:${{ steps.meta.outputs.SHORT_SHA }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ğŸ“‹ Display image info
        run: |
          echo "âœ… Images pushed successfully!"
          echo "ğŸ–¥ï¸  Server image: ${{ env.SERVER_IMAGE }}:latest"
          echo "ğŸŒ Client image: ${{ env.CLIENT_IMAGE }}:latest"
          echo "ğŸ·ï¸  Version: ${{ steps.meta.outputs.VERSION }}"
          echo "ğŸ“¦ SHA: ${{ steps.meta.outputs.SHORT_SHA }}"

  # Job 3: Deploy to AWS with Terraform
  deploy:
    needs: docker-build-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ·ï¸ Get image info
        id: image-info
        run: |
          echo "VERSION=v1.0.${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT

      - name: ï¿½ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: ï¿½ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1

      - name: ğŸ—ï¸ Update Terraform variables with new image tags
        run: |
          cd infra/terraform
          # CrÃ©er un fichier tfvars temporaire avec les nouvelles images
          cat >> terraform.tfvars.tmp << EOF
          server_image_tag = "${{ steps.image-info.outputs.VERSION }}"
          client_image_tag = "${{ steps.image-info.outputs.VERSION }}"
          docker_hub_username = "${{ secrets.DOCKER_USERNAME }}"
          EOF
          # Fusionner avec le fichier existant
          cat terraform.tfvars terraform.tfvars.tmp > terraform.tfvars.new
          mv terraform.tfvars.new terraform.tfvars
          rm terraform.tfvars.tmp

      - name: ğŸ” Terraform Init
        run: |
          cd infra/terraform
          terraform init

      - name: ğŸ“‹ Terraform Plan
        run: |
          cd infra/terraform
          terraform plan -out=tfplan

      - name: ğŸš€ Terraform Apply
        run: |
          cd infra/terraform
          terraform apply -auto-approve tfplan

      - name: ğŸ“Š Get deployment outputs
        id: terraform-outputs
        run: |
          cd infra/terraform
          echo "public_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
          echo "public_dns=$(terraform output -raw instance_public_dns)" >> $GITHUB_OUTPUT

      - name: â³ Wait for application to be ready
        run: |
          echo "â³ Attente que l'application soit prÃªte..."
          sleep 60
          
          # VÃ©rifier que l'application rÃ©pond
          max_retries=10
          retry_count=0
          
          while [ $retry_count -lt $max_retries ]; do
            if curl -f -s "http://${{ steps.terraform-outputs.outputs.public_ip }}" > /dev/null; then
              echo "âœ… Application prÃªte !"
              break
            else
              echo "â³ Tentative $((retry_count + 1))/$max_retries - En attente..."
              sleep 30
              retry_count=$((retry_count + 1))
            fi
          done

      - name: ğŸ‰ Deployment success notification
        run: |
          echo "::notice title=Deployment Success::ğŸ‰ Application deployed successfully on AWS!"
          echo "::notice title=Public IP::${{ steps.terraform-outputs.outputs.public_ip }}"
          echo "::notice title=Public DNS::${{ steps.terraform-outputs.outputs.public_dns }}"
          echo "::notice title=Frontend URL::http://${{ steps.terraform-outputs.outputs.public_ip }}"
          echo "::notice title=Backend URL::http://${{ steps.terraform-outputs.outputs.public_ip }}:3005"
          echo ""
          echo "ğŸŒ Application accessible Ã  :"
          echo "   - Frontend: http://${{ steps.terraform-outputs.outputs.public_ip }}"
          echo "   - Backend API: http://${{ steps.terraform-outputs.outputs.public_ip }}:3005"
          echo "   - DNS: http://${{ steps.terraform-outputs.outputs.public_dns }}"
